"""Base class for wrappers that execute a specific kind of battle.

The battle wrapper class is a base class for specific wrappers, which are
responsible for executing specific types of battle. They share the
characteristic that they are responsible for updating some match data during
their run, such that it contains the current state of the match.
"""
from __future__ import annotations
from dataclasses import dataclass
import logging
from abc import ABC, abstractmethod
from typing import TYPE_CHECKING, Any
if TYPE_CHECKING:
    from algobattle.match import Match, MatchData


logger = logging.getLogger('algobattle.battle_wrapper')


class BattleWrapper(ABC):
    """Base class for wrappers that execute a specific kind of battle."""

    @abstractmethod
    def __init__(self, **options: Any) -> None:
        """Builds a battle wrapper object with the given option values.
        Logs warnings if there were options provided that this wrapper doesn't use. 

        Parameters
        ----------
        options: dict[str, Any]
            Dict containing option values.
        """
        for arg, value in options.items():
            if arg not in vars(type(self)):
                logger.warning(f"Option '{arg}={value}' was provided, but is not used by {type(self)} type battles.")

    @abstractmethod
    def wrapper(self, match: Match) -> None:
        """The main base method for a wrapper.

        A wrapper should update the match.match_data object during its run. The callback functionality
        around it is executed automatically.

        It is assumed that the match.generating_team and match.solving_team are
        set before calling a wrapper.

        Parameters
        ----------
        match: Match
            The Match object on which the battle wrapper is to be executed on.
        """
        raise NotImplementedError

    @abstractmethod
    def calculate_points(self, match_data: MatchData, achievable_points: int) -> dict[str, float]:
        """Calculate the number of achieved points, given results.

        As awarding points completely depends on the type of battle that
        was fought, each wrapper should implement a method that determines
        how to split up the achievable points among all teams, given
        the match_data.

        Parameters
        ----------
        match_data : MatchData
            MatchData containing the results of match.run().
        achievable_points : int
            Number of achievable points.

        Returns
        -------
        dict
            A mapping between team names and their achieved points.
            The format is {team_name: points [...]} for each
            team for which there is an entry in match_data and points is a
            float value. Returns an empty dict if no battle was fought.
        """
        raise NotImplementedError

    def format_as_utf8(self, match_data: MatchData) -> str:
        """Format the match_data for the battle wrapper as a UTF-8 string.

        The output should not exceed 80 characters, assuming the default
        of a battle of 5 rounds.

        Parameters
        ----------
        match_data : MatchData
            MatchData containing match data generated by match.run().

        Returns
        -------
        str
            A formatted string on the basis of the match_data.
        """
        formatted_output_string = ""

        formatted_output_string += f'Battles of type {match_data.type} are currently not compatible with the ui.'
        formatted_output_string += f'Here is a dump of the match_data object anyway:\n{match_data}'

        return formatted_output_string
