"""Central managing module for an algorithmic battle."""
from __future__ import annotations
from itertools import combinations
import logging

from algobattle.battle_wrapper import BattleWrapper, BattleResult
from algobattle.team import Matchup, Team
from algobattle.fight_handler import FightHandler

logger = logging.getLogger('algobattle.match')


class Match:
    """Central managing class for an algorithmic battle."""

    def __init__(self, fight_handler: FightHandler, battle_wrapper: BattleWrapper, teams: list[Team], rounds: int = 5) -> None:
        self.fight_handler = fight_handler
        self.battle_wrapper = battle_wrapper
        self.teams = teams
        self.rounds = rounds

    @property
    def grouped_matchups(self) -> list[tuple[Matchup, Matchup]]:
        """All `Matchup`s, grouped by the involved teams.

        Each tuple's first matchup has the first team in the group generating, the second has it solving.
        """
        return [(Matchup(*g), Matchup(*g[::-1])) for g in combinations(self.teams, 2)]

    @property
    def matchups(self) -> list[Matchup]:
        """All 'Matchups` that will be fought."""
        return [m for pair in self.grouped_matchups for m in pair]

    def run(self) -> MatchResult:
        """Match entry point, executes fights between all teams."""
        result = MatchResult(self)
        for matchup in self.matchups:
            for i in range(self.rounds):
                logger.info("#" * 20 + f"  Running Round {i+1}/{self.rounds}  " + "#" * 20)
                battle_result = self.battle_wrapper.run_round(self.fight_handler, matchup)
                result[matchup].append(battle_result)
        return result

    def format_match_data_as_utf8(self) -> str:
        """Format the current match data in utf8 that can be output e.g. to STDOUT.

        Parameters
        ----------
        match_data : dict
            dict containing match data generated by match.run().

        Returns
        -------
        str
            A formatted string on the basis of the match_data.
        """
        battle_type = 'Battle Type: {}'.format(str(self.battle_wrapper))
        upper_border = self._format_delimiter_line_utf8(line_char='═', left_delim='╔', mid_delim='╦', right_delim='╗')
        header = self._format_header_line_utf8()
        separator = self._format_delimiter_line_utf8(line_char='─', left_delim='╟', mid_delim='╫', right_delim='╢')
        round_lines = self._format_round_lines_utf8()
        rounds_block = ''.join(['{}\n\r'.format(round_line) for round_line in round_lines])
        lower_border = self._format_delimiter_line_utf8(line_char='═', left_delim='╚', mid_delim='╩', right_delim='╝')

        return '{}\n\r{}\n\r{}\n\r{}\n\r{}{}\n\r'.format(battle_type,
                                                         upper_border,
                                                         header,
                                                         separator,
                                                         rounds_block,
                                                         lower_border)

    def _format_delimiter_line_utf8(self, line_char, left_delim, mid_delim, right_delim) -> str:
        """Helper function to draw delimiter lines, such as borders and seperator lines.

        Parameters
        ----------
        line_char : str
            Basic line character.
        left_delim : str
            Left delimiting character.
        mid_delim : str
            Middle delimiting character.
        right_delim : str
            Right delimiting character.

        Returns
        -------
        str
            A formatted delimiter string.
        """
        nheaders = len(self.battle_wrapper.format_misc_headers())
        rounds = self.rounds

        delimiter_start = '{}{}{}{}{}'.format(left_delim, 9 * line_char, mid_delim, 9 * line_char, mid_delim)
        additional_round_chunks = ('{}{}'.format(line_char * 9, mid_delim)) * rounds
        additional_misc_chunks = ('{}{}'.format(line_char * 9, mid_delim)) * (nheaders - 1)
        delimiter_end = '{}{}'.format(9 * line_char, right_delim)

        return delimiter_start + additional_round_chunks + additional_misc_chunks + delimiter_end

    def _format_header_line_utf8(self) -> str:
        """Helper function to format general and battle wrapper specific header strings.

        Returns
        -------
        str
            A formatted header string.
        """
        headers = self.battle_wrapper.format_misc_headers()
        rounds = self.rounds

        default_header = '║   GEN   ║   SOL   '
        additional_round_headers = ''.join(['║{:^9s}'.format('R' + str(i + 1)) for i in range(rounds)])
        additional_misc_headers = ''.join(['║{:>9s}'.format(headers[i]) for i in range(len(headers))])
        closing_header = '║'

        return default_header + additional_round_headers + additional_misc_headers + closing_header

    def _format_round_lines_utf8(self) -> list:
        """Helper function to format the round_data of each pairing of teams.

        Returns
        -------
        str
            A list of formatted round strings
        """
        round_lines = []
        for pair in self.all_battle_pairs():
            default_contents = '║{:>9s}║{:>9s}'.format(pair[0], pair[1])
            additional_round_contents = ''
            for round in range(self.rounds):
                round_data = self.match_data[pair][round]
                additional_round_contents += '║{:>9s}'.format(self.battle_wrapper.format_round_contents(round_data))

            latest_round = self.match_data[pair]['curr_round']
            latest_round_data = self.match_data[pair][latest_round]

            misc_contents = self.battle_wrapper.format_misc_contents(latest_round_data)
            additional_misc_contents = ''.join(['║{:>9s}'.format(misc_contents[i]) for i in range(len(misc_contents))])
            closing_contents = '║'

            round_lines.append(default_contents + additional_round_contents + additional_misc_contents + closing_contents)

        return round_lines

class MatchResult(dict[Matchup, list[BattleResult]]):
    """The Result of a `Match`."""

    def __init__(self, match: Match):
        self.match = match
        super().__init__({m: [] for group in match.grouped_matchups for m in group})

    def calculate_points(self, achievable_points: int) -> dict[Team, float]:
        """Calculate the number of points each team scored.

        Each pair of teams fights for the achievable points among one another.
        These achievable points are split over all rounds.
        """
        if len(self.match.teams) == 1:
            return {self.match.teams[0]: achievable_points}

        if any(not 0 <= len(results) <= self.match.rounds for results in self.values()):
            raise ValueError

        points = {team: 0. for team in self.match.teams}
        points_per_round = round(achievable_points / self.match.rounds, 1)

        for home_matchup, away_matchup in self.match.grouped_matchups:
            for home_res, away_res in zip(self[home_matchup], self[away_matchup]):
                total_score = home_res.score + away_res.score
                if total_score == 0:
                    # Default values for proportions, assuming no team manages to solve anything
                    home_ratio = 0.5
                    away_ratio = 0.5
                else:
                    home_ratio = home_res.score / total_score
                    away_ratio = away_res.score / total_score

                points[home_matchup.solver] += round(points_per_round * home_ratio, 1)
                points[away_matchup.solver] += round(points_per_round * away_ratio, 1)

        return points
