"""Central managing module for an algorithmic battle."""
from __future__ import annotations
from itertools import combinations
import logging
from typing import Any

from algobattle.battle_wrapper import BattleWrapper
from algobattle.team import Matchup, Team
from algobattle.fight_handler import FightHandler

logger = logging.getLogger('algobattle.match')


class Match:
    """Central managing class for an algorithmic battle."""

    def __init__(self, fight_handler: FightHandler, battle_wrapper: BattleWrapper, teams: list[Team], rounds: int = 5) -> None:
        self.fight_handler = fight_handler
        self.battle_wrapper = battle_wrapper
        self.teams = teams
        self.rounds = rounds

    @property
    def grouped_matchups(self) -> list[tuple[Matchup, Matchup]]:
        """All `Matchup`s, grouped by the involved teams.

        Each tuple's first matchup has the first team in the group generating, the second has it solving.
        """
        return [(Matchup(*g), Matchup(*g[::-1])) for g in combinations(self.teams, 2)]

    @property
    def matchups(self) -> list[Matchup]:
        """All 'Matchups` that will be fought."""
        return [m for pair in self.grouped_matchups for m in pair]

    def run(self) -> None:
        """Match entry point, executes fights between all teams."""
        result = MatchResult(self)
        for matchup in self.matchups:
            for i in range(self.rounds):
                logger.info("#" * 20 + f"  Running Round {i+1}/{self.rounds}  " + "#" * 20)
                battle_result = self.battle_wrapper.run_round(self.fight_handler, matchup)
                result[matchup].append(battle_result)

    def format_match_data_as_utf8(self) -> str:
        """Format the current match data in utf8 that can be output e.g. to STDOUT.

        Parameters
        ----------
        match_data : dict
            dict containing match data generated by match.run().

        Returns
        -------
        str
            A formatted string on the basis of the match_data.
        """
        battle_type = 'Battle Type: {}'.format(str(self.battle_wrapper))
        upper_border = self._format_delimiter_line_utf8(line_char='═', left_delim='╔', mid_delim='╦', right_delim='╗')
        header = self._format_header_line_utf8()
        separator = self._format_delimiter_line_utf8(line_char='─', left_delim='╟', mid_delim='╫', right_delim='╢')
        round_lines = self._format_round_lines_utf8()
        rounds_block = ''.join(['{}\n\r'.format(round_line) for round_line in round_lines])
        lower_border = self._format_delimiter_line_utf8(line_char='═', left_delim='╚', mid_delim='╩', right_delim='╝')

        return '{}\n\r{}\n\r{}\n\r{}\n\r{}{}\n\r'.format(battle_type,
                                                         upper_border,
                                                         header,
                                                         separator,
                                                         rounds_block,
                                                         lower_border)

    def _format_delimiter_line_utf8(self, line_char, left_delim, mid_delim, right_delim) -> str:
        """Helper function to draw delimiter lines, such as borders and seperator lines.

        Parameters
        ----------
        line_char : str
            Basic line character.
        left_delim : str
            Left delimiting character.
        mid_delim : str
            Middle delimiting character.
        right_delim : str
            Right delimiting character.

        Returns
        -------
        str
            A formatted delimiter string.
        """
        nheaders = len(self.battle_wrapper.format_misc_headers())
        rounds = self.rounds

        delimiter_start = '{}{}{}{}{}'.format(left_delim, 9 * line_char, mid_delim, 9 * line_char, mid_delim)
        additional_round_chunks = ('{}{}'.format(line_char * 9, mid_delim)) * rounds
        additional_misc_chunks = ('{}{}'.format(line_char * 9, mid_delim)) * (nheaders - 1)
        delimiter_end = '{}{}'.format(9 * line_char, right_delim)

        return delimiter_start + additional_round_chunks + additional_misc_chunks + delimiter_end

    def _format_header_line_utf8(self) -> str:
        """Helper function to format general and battle wrapper specific header strings.

        Returns
        -------
        str
            A formatted header string.
        """
        headers = self.battle_wrapper.format_misc_headers()
        rounds = self.rounds

        default_header = '║   GEN   ║   SOL   '
        additional_round_headers = ''.join(['║{:^9s}'.format('R' + str(i + 1)) for i in range(rounds)])
        additional_misc_headers = ''.join(['║{:>9s}'.format(headers[i]) for i in range(len(headers))])
        closing_header = '║'

        return default_header + additional_round_headers + additional_misc_headers + closing_header

    def _format_round_lines_utf8(self) -> list:
        """Helper function to format the round_data of each pairing of teams.

        Returns
        -------
        str
            A list of formatted round strings
        """
        round_lines = []
        for pair in self.all_battle_pairs():
            default_contents = '║{:>9s}║{:>9s}'.format(pair[0], pair[1])
            additional_round_contents = ''
            for round in range(self.rounds):
                round_data = self.match_data[pair][round]
                additional_round_contents += '║{:>9s}'.format(self.battle_wrapper.format_round_contents(round_data))

            latest_round = self.match_data[pair]['curr_round']
            latest_round_data = self.match_data[pair][latest_round]

            misc_contents = self.battle_wrapper.format_misc_contents(latest_round_data)
            additional_misc_contents = ''.join(['║{:>9s}'.format(misc_contents[i]) for i in range(len(misc_contents))])
            closing_contents = '║'

            round_lines.append(default_contents + additional_round_contents + additional_misc_contents + closing_contents)

        return round_lines

class MatchResult(dict[Matchup, list[Any]]):
    """The Result of a `Match`."""

    def __init__(self, match: Match):
        self.match = match
        super().__init__({m: [] for group in match.grouped_matchups for m in group})

    def calculate_points(self, achievable_points: int) -> dict[Team, float]:
        """Calculate the number of points each team scored.

        Each pair of teams fights for the achievable points among one another.
        These achievable points are split over all rounds.
        """
        if len(self.match.teams) == 1:
            return {self.match.teams[0]: achievable_points}

        if any(not 0 <= len(results) <= self.match.rounds for results in self.values()):
            raise ValueError

        points = {team: 0. for team in self.match.teams}
        points_per_round = round(achievable_points / self.match.rounds, 1)

        for matchup_home, matchup_away in self.match.grouped_matchups:
            for home, away in zip(self[matchup_home], self[matchup_away]):
                if home.score == away.score == 0:
                    # Default values for proportions, assuming no team manages to solve anything
                    home_points = 0.5
                    away_points = 0.5
                else:
                    home_points = home / (home + away)
                    away_points = away / (home + away)

                points[home.solver] += round(points_per_round * home_points, 1)
                points[away.solver] += round(points_per_round * away_points, 1)

        return points
