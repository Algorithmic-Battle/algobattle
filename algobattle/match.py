"""Central managing module for an algorithmic battle."""
from __future__ import annotations
from dataclasses import dataclass
from itertools import combinations
import logging
from typing import Any

from algobattle.battle_wrapper import BattleWrapper
from algobattle.team import Matchup, Team
from algobattle.util import update_nested_dict
from algobattle.subject import Subject
from algobattle.observer import Observer
from algobattle.fight_handler import FightHandler

logger = logging.getLogger('algobattle.match')


class Match(Subject, Observer):
    """Central managing class for an algorithmic battle."""

    _observers: list[Observer] = []

    def __init__(self, fight_handler: FightHandler, battle_wrapper: BattleWrapper, teams: list[Team], rounds: int = 5) -> None:
        self.fight_handler = fight_handler
        self.battle_wrapper = battle_wrapper
        self.battle_wrapper.attach(self)
        self.teams = teams
        self.rounds = rounds
        self.match_data: dict = {'type': str(self.battle_wrapper),
                                 'problem': str(self.fight_handler.problem),
                                 'teams': [str(team) for team in self.teams],
                                 'rounds': self.rounds}
        for pair in self.all_battle_pairs():
            for round in range(rounds):
                update_nested_dict(self.match_data, {pair: {'curr_round': 0, round: self.battle_wrapper.round_data}})

    @property
    def matchups(self) -> list[tuple[Matchup, Matchup]]:
        """All `Matchup`s, grouped by the involved teams.

        Each tuple's first matchup has the first team in the group generating, the second has it solving.
        """
        return [(Matchup(*g), Matchup(*g[::-1])) for g in combinations(self.teams, 2)]

    def run(self) -> None:
        """Match entry point, executes fights between all teams."""
        for pair in self.all_battle_pairs(as_team_objects=True):
            update_nested_dict(self.match_data, {'curr_pair': (str(pair[0]), str(pair[1]))})
            matchup = Matchup(pair[0], pair[1])

            for i in range(self.rounds):
                logger.info('{}  Running Battle {}/{}  {}'.format('#' * 20, i + 1, self.rounds, '#' * 20))
                update_nested_dict(self.match_data, {str(pair): {'curr_round': i}})
                self.battle_wrapper.run_round(self.fight_handler, matchup)

    def all_battle_pairs(self, as_team_objects=False) -> list:
        """Generate and return a list of all team pairings for battles."""
        battle_pairs = []
        for i in range(len(self.teams)):
            for j in range(len(self.teams)):
                if as_team_objects:
                    battle_pairs.append((self.teams[i], self.teams[j]))
                else:
                    battle_pairs.append((str(self.teams[i]), str(self.teams[j])))

        if not len(self.teams) == 1:
            battle_pairs = [pair for pair in battle_pairs if pair[0] != pair[1]]

        return battle_pairs

    def format_match_data_as_utf8(self) -> str:
        """Format the current match data in utf8 that can be output e.g. to STDOUT.

        Parameters
        ----------
        match_data : dict
            dict containing match data generated by match.run().

        Returns
        -------
        str
            A formatted string on the basis of the match_data.
        """
        battle_type = 'Battle Type: {}'.format(str(self.battle_wrapper))
        upper_border = self._format_delimiter_line_utf8(line_char='═', left_delim='╔', mid_delim='╦', right_delim='╗')
        header = self._format_header_line_utf8()
        separator = self._format_delimiter_line_utf8(line_char='─', left_delim='╟', mid_delim='╫', right_delim='╢')
        round_lines = self._format_round_lines_utf8()
        rounds_block = ''.join(['{}\n\r'.format(round_line) for round_line in round_lines])
        lower_border = self._format_delimiter_line_utf8(line_char='═', left_delim='╚', mid_delim='╩', right_delim='╝')

        return '{}\n\r{}\n\r{}\n\r{}\n\r{}{}\n\r'.format(battle_type,
                                                         upper_border,
                                                         header,
                                                         separator,
                                                         rounds_block,
                                                         lower_border)

    def _format_delimiter_line_utf8(self, line_char, left_delim, mid_delim, right_delim) -> str:
        """Helper function to draw delimiter lines, such as borders and seperator lines.

        Parameters
        ----------
        line_char : str
            Basic line character.
        left_delim : str
            Left delimiting character.
        mid_delim : str
            Middle delimiting character.
        right_delim : str
            Right delimiting character.

        Returns
        -------
        str
            A formatted delimiter string.
        """
        nheaders = len(self.battle_wrapper.format_misc_headers())
        rounds = self.rounds

        delimiter_start = '{}{}{}{}{}'.format(left_delim, 9 * line_char, mid_delim, 9 * line_char, mid_delim)
        additional_round_chunks = ('{}{}'.format(line_char * 9, mid_delim)) * rounds
        additional_misc_chunks = ('{}{}'.format(line_char * 9, mid_delim)) * (nheaders - 1)
        delimiter_end = '{}{}'.format(9 * line_char, right_delim)

        return delimiter_start + additional_round_chunks + additional_misc_chunks + delimiter_end

    def _format_header_line_utf8(self) -> str:
        """Helper function to format general and battle wrapper specific header strings.

        Returns
        -------
        str
            A formatted header string.
        """
        headers = self.battle_wrapper.format_misc_headers()
        rounds = self.rounds

        default_header = '║   GEN   ║   SOL   '
        additional_round_headers = ''.join(['║{:^9s}'.format('R' + str(i + 1)) for i in range(rounds)])
        additional_misc_headers = ''.join(['║{:>9s}'.format(headers[i]) for i in range(len(headers))])
        closing_header = '║'

        return default_header + additional_round_headers + additional_misc_headers + closing_header

    def _format_round_lines_utf8(self) -> list:
        """Helper function to format the round_data of each pairing of teams.

        Returns
        -------
        str
            A list of formatted round strings
        """
        round_lines = []
        for pair in self.all_battle_pairs():
            default_contents = '║{:>9s}║{:>9s}'.format(pair[0], pair[1])
            additional_round_contents = ''
            for round in range(self.rounds):
                round_data = self.match_data[pair][round]
                additional_round_contents += '║{:>9s}'.format(self.battle_wrapper.format_round_contents(round_data))

            latest_round = self.match_data[pair]['curr_round']
            latest_round_data = self.match_data[pair][latest_round]

            misc_contents = self.battle_wrapper.format_misc_contents(latest_round_data)
            additional_misc_contents = ''.join(['║{:>9s}'.format(misc_contents[i]) for i in range(len(misc_contents))])
            closing_contents = '║'

            round_lines.append(default_contents + additional_round_contents + additional_misc_contents + closing_contents)

        return round_lines

    def update(self, battle_wrapper: BattleWrapper) -> None:
        """Receive updates by observing the battle_wrapper object and integrate them into match_data.

        Parameters
        ----------
        battle_wrapper : BattleWrapper
            The observed battle_wrapper object.
        """
        if 'curr_pair' in self.match_data.keys():
            current_pair = self.match_data['curr_pair']
            if 'curr_round' in self.match_data[current_pair]:
                current_round = self.match_data[current_pair]['curr_round']
                update_nested_dict(self.match_data, {current_pair: {current_round: battle_wrapper.round_data}})
        self.notify()

    def attach(self, observer: Observer) -> None:
        """Subscribe a new Observer by adding them to the list of observers."""
        self._observers.append(observer)

    def detach(self, observer: Observer) -> None:
        """Unsubscribe an Observer by removing them from the list of observers."""
        self._observers.remove(observer)

    def notify(self) -> None:
        """Notify all subscribed Observers by calling their update() functions."""
        for observer in self._observers:
            observer.update(self)

class MatchResult(dict[Matchup, list[Any]]):
    """The Result of a `Match`."""

    def __init__(self, match: Match):
        self.match = match
        super().__init__({m: [] for group in match.matchups for m in group})

    def calculate_points(self, achievable_points: int) -> dict[Team, float]:
        """Calculate the number of points each team scored.

        Each pair of teams fights for the achievable points among one another.
        These achievable points are split over all rounds.
        """
        if len(self.match.teams) == 1:
            return {self.match.teams[0]: achievable_points}

        if any(not 0 <= len(results) <= self.match.rounds for results in self.values()):
            raise ValueError

        points = {team: 0. for team in self.match.teams}
        points_per_round = round(achievable_points / self.match.rounds, 1)

        for matchup_home, matchup_away in self.match.matchups:
            for home, away in zip(self[matchup_home], self[matchup_away]):
                if home.score == away.score == 0:
                    # Default values for proportions, assuming no team manages to solve anything
                    home_points = 0.5
                    away_points = 0.5
                else:
                    home_points = home / (home + away)
                    away_points = away / (home + away)

                points[home.solver] += round(points_per_round * home_points, 1)
                points[away.solver] += round(points_per_round * away_points, 1)

        return points
