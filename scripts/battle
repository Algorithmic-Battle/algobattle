#!/usr/bin/env python3
"""Main battle script. Executes all possible types of battles, see battle --help for all options."""
from __future__ import annotations, generators
from configparser import ConfigParser
import sys
import os
import logging

from argparse import ArgumentParser, Namespace
import datetime as dt
from pathlib import Path

import algobattle
from algobattle.match import Match
from algobattle.util import import_problem_from_path
from algobattle.docker import measure_runtime_overhead
from algobattle.ui import Ui
from algobattle.battle_wrappers import battle_wrappers

#! do not remove, even when unused!
import algobattle.sighandler

def setup_logging(logging_path: Path, verbose_logging: bool, silent: bool):
    """Creates and returns a parent logger.

    Parameters:
    ----------
    logging_path : Path
        Path to folder where the logfile should be stored at.
    verbose_logging : bool
        Flag indicating whether to include debug messages in the output
    silent : bool
        Flag indicating whether not to pipe the logging output to stderr.

    Returns:
    ----------
    Logger:
        The Logger object.
    """
    common_logging_level = logging.INFO

    if verbose_logging:
        common_logging_level = logging.DEBUG

    logging_path.mkdir(parents=True, exist_ok=True)

    _now = dt.datetime.now()

    time_seperator = ":" if os.name == "posix" else "-"
    current_timestamp = f"{_now.year:04d}-{_now.month:02d}-{_now.day:02d}_{_now.hour:02d}{time_seperator}{_now.minute:02d}{time_seperator}{_now.second:02d}"
    logging_path /= current_timestamp + ".log"

    logging.basicConfig(handlers=[logging.FileHandler(logging_path, "w", "utf-8")],
                        level=common_logging_level,
                        format="%(asctime)s %(levelname)s: %(message)s",
                        datefmt="%H:%M:%S")

    logger = logging.getLogger("algobattle")

    if not silent:
        # Pipe logging out to console
        _consolehandler = logging.StreamHandler(stream=sys.stderr)
        _consolehandler.setLevel(common_logging_level)

        _consolehandler.setFormatter(logging.Formatter("%(message)s"))

        logger.addHandler(_consolehandler)

    logger.info(f"You can find the log files for this run in {logging_path}")
    return logger

battle_arg_spec = {
    "rounds": {"type": int, "default": 5, "help": "Number of rounds that are to be fought in the battle (points are split between all rounds). Default: 5"},
}
def create_parser() -> ArgumentParser:

    default_logging_path = Path.home() / ".algobattle_logs"
    def resolved_path(path: str) -> Path:
        return Path(path).resolve()

    parser = ArgumentParser()
    parser.add_argument("problem_path", type=resolved_path, help="Path to the parent directory of a problem file as argument.")
    parser.add_argument("--version", action="version", version=f"Algobattle version {algobattle.__version__}")
    parser.add_argument("--teams", "-t", action="extend", type=resolved_path, nargs="*", help="Any number of paths that specify teams. Either by the found folder structure or a team.ini file found there. Defaults to the problem path.")
    parser.add_argument("--config", "-c", type=resolved_path, help="Path to a .ini configuration file to be used for the run. Defaults to either the 'config.ini' file in the problem folder if it exists or the packages config.ini")
    parser.add_argument("--logging_folder", "-o", type=resolved_path, default=default_logging_path, help="Specify the folder into which the log file is written to. Can either be a relative or absolute path to folder. If nonexisting, a new folder will be created. Default: ~/.algobattle_logs/")
    parser.add_argument("--verbose", action="store_true", help="Log all debug messages.")
    parser.add_argument("--display", "-d", choices=["silent", "ui", "logs"], default="logs", help="Choose display mode, silent will hide all output, logs will pipe the logs to stderr, and ui will display a small terminal ui. Default: logs")
    parser.add_argument("--no_overhead_calculation", action="store_true", help="If set, the program does not benchmark the I/O of the host system to calculate the runtime overhead when started.")
    parser.add_argument("--no_cleanup", action="store_true", help="Don't clean up any created docker images.")
    parser.add_argument("--points", "-p", type=int, default="100", help="Number of points that are to be fought for. Default: 100")
    parser.add_argument("--do_not_count_points", action="store_true", help="If set, points are not calculated for the run.")

    battle_args = parser.add_argument_group("battle arguments")
    battle_args.add_argument("battle_type", choices=battle_wrappers.keys(), nargs="?", help="Type of battle, has to be set in the command line or in config file")
    for name, kwargs in battle_arg_spec.items():
        battle_args.add_argument(f"--{name}", **(kwargs | {"default": None}))
    
    for name, cls in battle_wrappers.items():
        cls_args = battle_args.add_argument_group(name)
        for name, kwargs in cls.get_cli_parameters().items():
            cls_args.add_argument(f"--{name}", **(kwargs | {"default": None}))
    
    return parser

def parse_args() -> Namespace:
    options = create_parser().parse_args()
    
    if not options.problem_path.exists():
        sys.exit(f"Problem path '{options.problem_path}' does not exist in the file system! Use 'battle --help' for more information on usage and options.")
    
    working_dir: Path = options.problem_path
    if working_dir.is_file():
        working_dir = working_dir.parent

    if options.config is None:
        if (working_dir / "config.ini").is_file():
            options.config = options.problem_path / "config.ini"
        else:
            options.config = Path(algobattle.__file__).resolve().parent / "config" / "config.ini"
    elif not options.config.exists():
        sys.exit(f"Config path '{options.config}' does not exist in the file system! Use 'battle --help' for more information on usage and options.")
    elif options.config.is_folder():
        options.config /= "config.ini"
    
    if options.teams is None:
        options.teams = [working_dir]

    return options

def parse_config(options: Namespace) -> Namespace:
    config = ConfigParser()
    config.read(options.config)
    battle_options = Namespace()

    if options.battle_type is not None:
        battle_type = options.battle_type
    elif "battle_type" in config["battle"]:
        battle_type = config["battle"]["battle_type"]
    else:
        sys.exit("The battle type was not specified in the command line or the config file! Use 'battle --help' for more information on usage and options.")
    
    for name, kwargs in battle_arg_spec.items():
        if getattr(options, name) is not None:
            setattr(battle_options, name, options.name)
        elif "battle" in config and name in config["battle"]:
            setattr(battle_options, name, kwargs["type"](config["battle"][name]))
        else:
            setattr(battle_options, name, kwargs["default"])
    
    for name, kwargs in battle_wrappers[battle_type].get_cli_parameters().items():
        if getattr(options, name) is not None:
            setattr(battle_options, name, options.name)
        elif battle_type in config and name in config[battle_type]:
            setattr(battle_options, name, kwargs["type"](config[battle_type][name]))
        else:
            setattr(battle_options, name, kwargs["default"])
    
    battle_options.battle_type = battle_type
    battle_options.run_parametersAA = config["run_parameters"]

    return battle_options
    

def parse_team_info(teams: list[Path]) -> list[tuple[str, Path, Path]]:
    team_info: list[tuple[str, Path, Path]] = []
    for path in teams:
        if (path / "team.ini").exists():
            config = ConfigParser(allow_no_value=True)
            config.read(path / "team.ini")
            config = config["team"]
            name = config.get("name", path.name)
            generator = config.getpath("generator", path / "generator")
            solver = config.getpath("solver", path / "solver")
            team_info.append((name, generator, solver))
        else:
            team_info.append((path.name, path / "generator", path / "solver"))
    
    for name, gen_path, sol_path in team_info:
        for role, path in [("generator", gen_path), ("solver", sol_path)]:
            if not path.exists:
                sys.exit(f"The {role} path {gen_path} used by team '{name}' does not exist in the file system! Use 'battle --help' for more information on usage and options.")
    
    return team_info

if __name__ == "__main__":
    
    options = parse_args()

    logger = setup_logging(options.logging_folder, options.verbose, options.display != "logs")

    config = parse_config(options)
    
    try:
        problem = import_problem_from_path(options.problem_path)
    except ValueError:
        sys.exit(f"Could not import the problem! Check the logs and use 'battle --help' for more information on usage and options.")

    logger.debug(f"Options for this run: {options}")

    if options.display == "ui":
        ui = Ui(logger, logger.getEffectiveLevel())
        ui.update("Setting up match...")
    else:
        ui = None
    
    runtime_overhead = 0
    if not options.no_overhead_calculation:
        logger.info('Running a benchmark to determine your machines I/O overhead to start and stop docker containers...')
        runtime_overhead = measure_runtime_overhead()
        logger.info(f'Maximal measured runtime overhead is at {runtime_overhead} seconds. Adding this amount to the configured runtime.')

    team_info = parse_team_info(options.teams)
    match = Match(problem, config.run_parametersAA, team_info, ui, runtime_overhead)
    results = match.run(**vars(config))

    if ui is not None:
        ui.restore()

    logger.info("#" * 78)
    logger.info(f"\n{results.format()}")
    if not options.do_not_count_points:
        points = results.calculate_points(options.points)
        for team, points in points.items():
            logger.info(f"Group {team} gained {points:.1f} points.")
    
    if not options.no_cleanup:
        match.cleanup()
    if options.display != "silent":
        print(results.format())
