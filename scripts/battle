#!/usr/bin/env python3
"""Main battle script. Executes all possible types of battles, see battle --help for all options."""
from __future__ import annotations, generators
from configparser import ConfigParser
import sys
import os
import logging

from argparse import ArgumentParser
import datetime as dt
from pathlib import Path

import algobattle
from algobattle.match import Match
from algobattle.util import import_problem_from_path
from algobattle.docker import measure_runtime_overhead
from algobattle.ui import Ui
from algobattle.battle_wrapper import BattleWrapper

#! do not remove, even when unused!
import algobattle.sighandler
import algobattle.battle_wrappers   # type: ignore

def setup_logging(logging_path: Path, verbose_logging: bool, silent: bool):
    """Creates and returns a parent logger.

    Parameters:
    ----------
    logging_path : Path
        Path to folder where the logfile should be stored at.
    verbose_logging : bool
        Flag indicating whether to include debug messages in the output
    silent : bool
        Flag indicating whether not to pipe the logging output to stderr.

    Returns:
    ----------
    Logger:
        The Logger object.
    """
    common_logging_level = logging.INFO

    if verbose_logging:
        common_logging_level = logging.DEBUG

    logging_path.mkdir(parents=True, exist_ok=True)

    _now = dt.datetime.now()

    time_seperator = ":" if os.name == "posix" else "-"
    current_timestamp = f"{_now.year:04d}-{_now.month:02d}-{_now.day:02d}_{_now.hour:02d}{time_seperator}{_now.minute:02d}{time_seperator}{_now.second:02d}"
    logging_path /= current_timestamp + ".log"

    logging.basicConfig(handlers=[logging.FileHandler(logging_path, "w", "utf-8")],
                        level=common_logging_level,
                        format="%(asctime)s %(levelname)s: %(message)s",
                        datefmt="%H:%M:%S")

    logger = logging.getLogger("algobattle")

    if not silent:
        # Pipe logging out to console
        _consolehandler = logging.StreamHandler(stream=sys.stderr)
        _consolehandler.setLevel(common_logging_level)

        _consolehandler.setFormatter(logging.Formatter("%(message)s"))

        logger.addHandler(_consolehandler)

    logger.info(f"You can find the log files for this run in {logging_path}")
    return logger

def resolved_path(path: str) -> Path:
    return Path(path).resolve()

def extend_default_path(path: str, problem_path: Path) -> Path:
    return resolved_path(path.format(problem_path=problem_path))

if __name__ == "__main__":
    default_logging_path = Path.home() / ".algobattle_logs"
    default_config = Path(algobattle.__file__).resolve().parent / "config" / "config.ini"

    parent_parser = ArgumentParser(add_help=False)
    parent_parser.add_argument("--teams", "-t", action="extend", nargs="*", help="Any number of paths that specify teams. Either by the found folder structure or a team.ini file found there. Defaults to the problem path.")
    parent_parser.add_argument("--version", action="version", version=f"Algobattle version {algobattle.__version__}")
    parent_parser.add_argument("--verbose", dest="verbose_logging", action="store_true", help="Log all debug messages.")
    parent_parser.add_argument("--display", "-d", choices=["silent", "ui", "logs"], default="logs", help="Choose display mode, silent will hide all output, logs will pipe the logs to stderr, and ui will display a small terminal ui. Default: logs")
    parent_parser.add_argument("--output_folder", "-o", dest="folder_name", type=resolved_path, default=default_logging_path, help="Specify the folder into which the log file is written to. Can either be a relative or absolute path to folder. If nonexisting, a new folder will be created. Default: ~/.algobattle_logs/")
    parent_parser.add_argument("--config_file", "-c", dest="config", type=resolved_path, default=default_config, help="Path to a .ini configuration file to be used for the run. Defaults to the packages config.ini")
    parent_parser.add_argument("--no_overhead_calculation", dest="no_overhead_calculation", action="store_true", help="If set, the program does not benchmark the I/O of the host system to calculate the runtime overhead when started.")
    parent_parser.add_argument("--no_cleanup", action="store_true", help="Don't clean up any created docker images.")
    parent_parser.add_argument("--rounds", "-r", dest="battle_rounds", type=int, default="5", help="Number of rounds that are to be fought in the battle (points are split between all rounds). Default: 5")
    parent_parser.add_argument("--points", "-p", dest="points", type=int, default="100", help="Number of points that are to be fought for. Default: 100")
    parent_parser.add_argument("--do_not_count_points", dest="do_not_count_points", action="store_true", help="If set, points are not calculated for the run.")
    
    parser = ArgumentParser(parents=[parent_parser])
    parent_parser.add_argument("problem_path", type=resolved_path, help="Path to the parent directory of a problem file as argument.")

    subparsers = parser.add_subparsers(help="Type of battle to run.", dest="battle_type", required=True)
    for name, cls in BattleWrapper.wrapper_classes.items():
        battle_parser = subparsers.add_parser(name, parents=[parent_parser])
        for args, kwargs in cls.battle_args:
            battle_parser.add_argument(*args, **kwargs)

    options = parser.parse_args()

    if not options.problem_path.exists():
        sys.exit(f"Problem path '{options.problem_path}' does not exist in the file system! Use 'battle --help' for more information on usage and options.")
    
    if options.teams is None:
        team_paths = [options.problem_path]
    else:
        team_paths = [resolved_path(p) for p in options.teams]

    team_info: list[tuple[str, Path, Path]] = []
    for path in team_paths:
        if (path / "team.ini").exists():
            config = ConfigParser(converters={"path": resolved_path})
            config.read(path / "team.ini")
            config = config["team"]
            name = config.get("name", path.name)
            generator = config.getpath("generator", path / "generator")
            solver = config.getpath("solver", path / "solver")
            team_info.append((name, generator, solver))
        else:
            team_info.append((path.name, path / "generator", path / "solver"))
    
    for name, gen_path, sol_path in team_info:
        for role, path in [("generator", gen_path), ("solver", sol_path)]:
            if not path.exists:
                sys.exit(f"The {role} path {gen_path} used by team '{name}' does not exist in the file system! Use 'battle --help' for more information on usage and options.")
            
    if not options.config.exists():
        sys.exit(f"Config path '{options.config}'' does not exist in the file system! Use 'battle --help' for more information on usage and options.")

    logger = setup_logging(options.folder_name, options.verbose_logging, options.display != "logs")

    problem = import_problem_from_path(options.problem_path)
    if not problem:
        sys.exit(1)

    logger.debug(f"Options for this run: {options}")
    logger.debug(f"Contents of sys.argv: {sys.argv}")

    if options.display == "ui":
        ui = Ui(logger, logger.getEffectiveLevel())
        ui.update("Setting up match...")
    else:
        ui = None

    runtime_overhead = 0
    if not options.no_overhead_calculation:
        logger.info("Running a benchmark to determine your machines I/O overhead to start and stop docker containers...")
        runtime_overhead = measure_runtime_overhead()
        logger.info(f"Maximal measured runtime overhead is at {runtime_overhead} seconds. Adding this amount to the configured runtime.")

    
    match = Match(problem, options.config, team_info, ui, runtime_overhead=runtime_overhead, approximation_ratio=options.approximation_ratio)


    results = match.run(options.battle_type, rounds=options.battle_rounds, iterated_cap=options.iterated_cap,
                        iterated_exponent=options.iterated_exponent, approximation_instance_size=options.approximation_instance_size,
                        approximation_iterations=options.approximation_iterations)

    if ui is not None:
        ui.restore()

    logger.info("#" * 78)
    logger.info(f"\n{results.format()}")
    if not options.do_not_count_points:
        points = results.calculate_points(options.points)
        for team, points in points.items():
            logger.info(f"Group {team} gained {points:.1f} points.")
    
    if not options.no_cleanup:
        match.cleanup()
    if options.display != "silent":
        print(results.format())
