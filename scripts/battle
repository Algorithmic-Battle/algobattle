#!/usr/bin/env python3
"""Main battle script. Executes all possible types of battles, see battle --help for all options."""
from __future__ import annotations, generators
from configparser import ConfigParser
import sys
import os
import logging

from argparse import _StoreConstAction, ArgumentParser, Namespace
import datetime as dt
from pathlib import Path

import algobattle
from algobattle.match import Match
from algobattle.util import import_problem_from_path
from algobattle.docker import measure_runtime_overhead
from algobattle.ui import Ui
from algobattle.battle_wrappers import battle_wrappers

#! do not remove, even when unused!
import algobattle.sighandler

def setup_logging(logging_path: Path, verbose_logging: bool, silent: bool):
    """Creates and returns a parent logger.

    Parameters:
    ----------
    logging_path : Path
        Path to folder where the logfile should be stored at.
    verbose_logging : bool
        Flag indicating whether to include debug messages in the output
    silent : bool
        Flag indicating whether not to pipe the logging output to stderr.

    Returns:
    ----------
    Logger:
        The Logger object.
    """
    common_logging_level = logging.INFO

    if verbose_logging:
        common_logging_level = logging.DEBUG

    logging_path.mkdir(parents=True, exist_ok=True)

    _now = dt.datetime.now()

    time_seperator = ":" if os.name == "posix" else "-"
    current_timestamp = f"{_now.year:04d}-{_now.month:02d}-{_now.day:02d}_{_now.hour:02d}{time_seperator}{_now.minute:02d}{time_seperator}{_now.second:02d}"
    logging_path /= current_timestamp + ".log"

    logging.basicConfig(handlers=[logging.FileHandler(logging_path, "w", "utf-8")],
                        level=common_logging_level,
                        format="%(asctime)s %(levelname)s: %(message)s",
                        datefmt="%H:%M:%S")

    logger = logging.getLogger("algobattle")

    if not silent:
        # Pipe logging out to console
        _consolehandler = logging.StreamHandler(stream=sys.stderr)
        _consolehandler.setLevel(common_logging_level)

        _consolehandler.setFormatter(logging.Formatter("%(message)s"))

        logger.addHandler(_consolehandler)

    logger.info(f"You can find the log files for this run in {logging_path}")
    return logger

def resolved_path(path: str) -> Path:
    return Path(path).resolve()

def create_parsers() -> dict[str, ArgumentParser]:
    default_logging_path = Path.home() / ".algobattle_logs"
    default_config = Path(algobattle.__file__).resolve().parent / "config" / "config.ini"

    parent_parser = ArgumentParser(add_help=False)
    parent_parser.add_argument("--teams", "-t", action="extend", type=resolved_path, nargs="*", help="Any number of paths that specify teams. Either by the found folder structure or a team.ini file found there. Defaults to the problem path.")
    parent_parser.add_argument("--config_file", "-c", dest="config", type=resolved_path, default=default_config, help="Path to a .ini configuration file to be used for the run. Defaults to the packages config.ini")
    parent_parser.add_argument("--output_folder", "-o", dest="folder_name", type=resolved_path, default=default_logging_path, help="Specify the folder into which the log file is written to. Can either be a relative or absolute path to folder. If nonexisting, a new folder will be created. Default: ~/.algobattle_logs/")

    parent_parser.add_argument("--version", action="version", version=f"Algobattle version {algobattle.__version__}")
    parent_parser.add_argument("--verbose", dest="verbose_logging", action="store_true", help="Log all debug messages.")
    parent_parser.add_argument("--display", "-d", choices=["silent", "ui", "logs"], default="logs", help="Choose display mode, silent will hide all output, logs will pipe the logs to stderr, and ui will display a small terminal ui. Default: logs")
    parent_parser.add_argument("--no_overhead_calculation", dest="no_overhead_calculation", action="store_true", help="If set, the program does not benchmark the I/O of the host system to calculate the runtime overhead when started.")
    parent_parser.add_argument("--no_cleanup", action="store_true", help="Don't clean up any created docker images.")
    parent_parser.add_argument("--rounds", "-r", dest="battle_rounds", type=int, default="5", help="Number of rounds that are to be fought in the battle (points are split between all rounds). Default: 5")
    parent_parser.add_argument("--points", "-p", dest="points", type=int, default="100", help="Number of points that are to be fought for. Default: 100")
    parent_parser.add_argument("--do_not_count_points", dest="do_not_count_points", action="store_true", help="If set, points are not calculated for the run.")
    for action in parent_parser._actions:
        if isinstance(action, _StoreConstAction):
            action.type = lambda s: s.lower() == "true"

    parser = ArgumentParser(parents=[parent_parser])
    parser.add_argument("problem_path", type=resolved_path, help="Path to the parent directory of a problem file as argument.")

    subparsers = parser.add_subparsers(help="Type of battle to run.", dest="battle_type", required=True)
    for name, cls in battle_wrappers.items():
        battle_parser = subparsers.add_parser(name, parents=[parent_parser])
        battle_args = battle_parser.add_argument_group(f"{name} battle arguments")
        for args, kwargs in cls.get_cli_parameters():
            battle_args.add_argument(*args, **kwargs)
    return subparsers.choices | {"battle": parser}

def parse_args() -> Namespace:
    pre_parser = ArgumentParser(add_help=False)
    pre_parser.add_argument("path", nargs="?")
    pre_parser.add_argument("type", nargs="?")
    pre_parser.add_argument("--config", "-c", type=resolved_path)
    pre_options, _ = pre_parser.parse_known_args()

    argv = sys.argv[:]
    parsers = create_parsers()

    if pre_options.path is not None:
        if pre_options.config == None:
            config_path: Path = resolved_path(pre_options.path)
        else:
            config_path: Path = pre_options.config
        if not config_path.is_file() and (config_path / "config.ini").is_file():
            config_path /= "config.ini"

        if config_path.is_file():
            config = ConfigParser()
            config.read(config_path)
            for name, section in config.items():
                if name in parsers:
                    parsers[name].set_defaults(**section)
                    if name == "battle" and "battle_type" in section and pre_options.type is None:
                        argv.insert(argv.index(pre_options.path)+1, section["battle_type"])

    return parsers["battle"].parse_args(argv[1:])

def parse_team_info(teams: list[Path]) -> list[tuple[str, Path, Path]]:
    team_info: list[tuple[str, Path, Path]] = []
    for path in teams:
        if (path / "team.ini").exists():
            config = ConfigParser(converters={"path": resolved_path})
            config.read(path / "team.ini")
            config = config["team"]
            name = config.get("name", path.name)
            generator = config.getpath("generator", path / "generator")
            solver = config.getpath("solver", path / "solver")
            team_info.append((name, generator, solver))
        else:
            team_info.append((path.name, path / "generator", path / "solver"))
    
    for name, gen_path, sol_path in team_info:
        for role, path in [("generator", gen_path), ("solver", sol_path)]:
            if not path.exists:
                sys.exit(f"The {role} path {gen_path} used by team '{name}' does not exist in the file system! Use 'battle --help' for more information on usage and options.")
    
    return team_info

if __name__ == "__main__":
    
    options = parse_args()

    logger = setup_logging(options.folder_name, options.verbose_logging, options.display != "logs")
          
    if not options.config.exists():
        sys.exit(f"Config path '{options.config}'' does not exist in the file system! Use 'battle --help' for more information on usage and options.")

    config = ConfigParser()
    logger.debug(f'Using additional configuration options from file "{options.config}".')
    config.read(options.config)
    
    try:
        problem = import_problem_from_path(options.problem_path)
    except ValueError:
        sys.exit(f"Could not import the problem! Check the logs and use 'battle --help' for more information on usage and options.")


    logger.debug(f"Options for this run: {options}")

    if options.display == "ui":
        ui = Ui(logger, logger.getEffectiveLevel())
        ui.update("Setting up match...")
    else:
        ui = None
    
    runtime_overhead = 0
    if not options.no_overhead_calculation:
        logger.info('Running a benchmark to determine your machines I/O overhead to start and stop docker containers...')
        runtime_overhead = measure_runtime_overhead()
        logger.info(f'Maximal measured runtime overhead is at {runtime_overhead} seconds. Adding this amount to the configured runtime.')

    if options.teams is None:
        options.teams = [options.problem_path]
    team_info = parse_team_info(options.teams)
    match = Match(problem, config, team_info, ui, runtime_overhead)


    results = match.run(**vars(options))

    if ui is not None:
        ui.restore()

    logger.info("#" * 78)
    logger.info(f"\n{results.format()}")
    if not options.do_not_count_points:
        points = results.calculate_points(options.points)
        for team, points in points.items():
            logger.info(f"Group {team} gained {points:.1f} points.")
    
    if not options.no_cleanup:
        match.cleanup()
    if options.display != "silent":
        print(results.format())
